# =============================================================================
# Documentation Platform - 基礎配置（正式環境就緒）
# =============================================================================
# 此檔案包進 Docker Image，配置以正式環境為基準
# 本地開發差異透過 profile 覆蓋：
#   - local: Docker Compose 基礎設施（application-local.yaml）
#   - dev:   除錯日誌、OTLP 停用、Liquibase 啟用（config/application-dev.yaml）
# Cloud Run 設定 SPRING_PROFILES_ACTIVE 覆蓋預設 profiles，僅載入此檔案
# =============================================================================

spring:
  application:
    name: Documentation Platform

  profiles:
    # 本地開發預設啟用 local + dev profiles
    # Cloud Run 透過 SPRING_PROFILES_ACTIVE 覆蓋，停用這些 profiles
    default: local,dev

  threads:
    virtual:
      enabled: true  # Java 21+ Virtual Threads

  # ----- SQL 初始化配置 -----
  # 停用 schema.sql 執行，所有 schema 變更由 Liquibase 管理
  sql:
    init:
      mode: never

  # ----- Liquibase 配置 -----
  # 正式環境由 Cloud Run Job 執行資料庫遷移，應用程式啟動時不執行
  # 避免多個實例同時啟動造成 DATABASECHANGELOGLOCK 鎖定競爭
  # 本地開發由 dev profile 覆蓋為 enabled: true
  liquibase:
    enabled: false

  # ----- 優雅關機超時 -----
  # Cloud Run SIGTERM 後有 10 秒寬限期，預留 2 秒給 JVM 清理
  lifecycle:
    timeout-per-shutdown-phase: 8s

  # ----- 資料庫配置 -----
  datasource:
    url: ${platform-db-url:jdbc:postgresql://localhost:5432/mydatabase}
    username: ${platform-db-username:myuser}
    password: ${platform-db-password:secret}
    hikari:
      # 連線池大小：Cloud Run 1-2 vCPU 建議 5（公式：core_count * 2 + 1）
      maximum-pool-size: 5
      # 固定連線池：最小空閒數 = 最大值（HikariCP 官方建議最佳效能配置）
      minimum-idle: 5
      # 等待連線的最大毫秒數
      connection-timeout: 10000
      # 空閒連線超時（10 分鐘）
      idle-timeout: 600000
      # 連線最大存活時間（28 分鐘，須小於 Cloud SQL idle timeout 30 分鐘）
      max-lifetime: 1680000
      # 連線保活間隔（5 分鐘，防止 Auth Proxy 關閉閒置連線）
      keepalive-time: 300000
      # 連線池名稱（便於監控識別）
      pool-name: DocPlatformPool

  # ----- OAuth2 配置 -----
  # 機敏資訊透過環境變數或 Secret Manager 注入
  # 由 platform.features.oauth2 開關控制是否啟用
  security:
    oauth2:
      client:
        registration:
          omnihubs:
            client-id: ${platform-oauth2-client-id:}
            client-secret: ${platform-oauth2-client-secret:}
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/api/oauth2/callback/{registrationId}"
            scope:
              - openid
              - profile
              - email
        provider:
          omnihubs:
            # 僅設定 issuer-uri，其餘端點由 OIDC Discovery 自動取得
            # Spring Security 會從 {issuer-uri}/.well-known/openid-configuration 發現所有端點
            # 避免手動拼接 URL 導致的尾斜線問題
            issuer-uri: ${platform-oauth2-issuer-uri:https://auth.omnihubs.cloud}
            user-name-attribute: sub
      # Resource Server JWT 驗證配置
      resourceserver:
        jwt:
          issuer-uri: ${platform-oauth2-issuer-uri:https://auth.omnihubs.cloud}

  # ----- Spring AI 配置 -----
  ai:
    # Google GenAI Embedding 配置
    google:
      genai:
        embedding:
          # 從統一屬性名稱讀取（本地: secrets.properties, GCP: Secret Manager）
          api-key: ${platform-google-api-key:}
          text:
            options:
              model: gemini-embedding-001
              # 指定輸出維度（gemini-embedding-001 預設 3072，需設為 768 與資料庫一致）
              dimensions: 768

    # PgVector 向量儲存配置
    vectorstore:
      pgvector:
        dimensions: 768
        distance-type: COSINE_DISTANCE
        index-type: HNSW

# ----- Server 配置 -----
server:
  # 優雅關機：收到 SIGTERM 後停止接收新請求，等待進行中的請求完成
  shutdown: graceful
  tomcat:
    # 連線超時
    connection-timeout: 5s

# ----- Actuator / Management 配置 -----
management:
  endpoints:
    web:
      exposure:
        # 健康檢查、應用資訊、Micrometer 指標、Prometheus 格式指標
        include: health,info,metrics,prometheus
  endpoint:
    health:
      probes:
        # 啟用 Kubernetes/Cloud Run 探針端點
        # /actuator/health/liveness  - 程序存活檢查（不含外部依賴，避免 DB 故障造成雪崩重啟）
        # /actuator/health/readiness - 服務就緒檢查（含資料庫等依賴）
        enabled: true
      # 健康檢查詳細資訊僅授權用戶可見（防止洩漏內部連線資訊）
      # 本地開發由 dev profile 覆蓋為 always
      show-details: when-authorized
      show-components: when-authorized

  # ----- OpenTelemetry 追蹤配置 -----
  tracing:
    sampling:
      # 追蹤取樣率（1.0 = 100%，可透過環境變數調降以減少成本）
      probability: 1.0

  # ----- OTLP 匯出配置 -----
  # 連線至 OTel Collector Sidecar（Cloud Run 多容器架構）
  # 本地開發由 dev profile 停用（無 Collector）
  #
  # Spring Boot 4 分為兩個 namespace：
  #   - management.otlp.metrics.*           → Micrometer OTLP exporter（僅 HTTP）
  #   - management.opentelemetry.{signal}.* → OpenTelemetry SDK（支援 gRPC / HTTP）
  #
  # Sidecar 模式推薦 gRPC（單一 TCP 多路複用、低延遲）
  # Metrics 因 Micrometer 限制只能走 HTTP
  #   Metrics → HTTP localhost:4318/v1/metrics
  #   Tracing → gRPC localhost:4317
  #   Logging → gRPC localhost:4317
  otlp:
    metrics:
      export:
        url: http://localhost:4318/v1/metrics

  # OTLP Logging 匯出啟用開關
  logging:
    export:
      otlp:
        enabled: true

  # ----- OpenTelemetry SDK 匯出配置 -----
  opentelemetry:
    # Tracing OTLP 匯出（gRPC，效能優於 HTTP）
    tracing:
      export:
        otlp:
          endpoint: http://localhost:4317
          transport: grpc
    # Logging OTLP 匯出（gRPC，效能優於 HTTP）
    logging:
      export:
        otlp:
          endpoint: http://localhost:4317
          transport: grpc
    # 資源屬性（附加於所有 traces/metrics/logs）
    resource-attributes:
      service.name: documentation-platform
      service.version: ${project.version:0.0.1-SNAPSHOT}
      deployment.environment: production

# ----- Platform 配置 -----
platform:
  # ----- 已知函式庫文件路徑對應表 -----
  # 用於自動帶入 GitHub 函式庫的文件路徑
  # 支援兩種格式：
  # 1. 簡單格式：直接是路徑字串（適用於無版本差異的函式庫）
  # 2. 版本範圍格式：包含 default 和 versions（適用於有版本差異的函式庫）
  known-docs-paths:
    # Spring Boot: 4.x 與 3.x 目錄結構不同
    spring-projects/spring-boot:
      default: "documentation/spring-boot-docs/src/docs/antora"  # 4.x 預設
      versions:
        "3.*": "spring-boot-project/spring-boot-docs/src/docs/antora"  # 3.x
    spring-projects/spring-framework: "framework-docs/modules/ROOT/pages"
    facebook/react: "docs"
    vuejs/vue: "docs"
    kubernetes/kubernetes: "website/content/en/docs"
    docker/docs: "content"
    microsoft/TypeScript: "doc"
    golang/go: "doc"

  # ----- 功能開關 -----
  features:
    # OAuth2 認證
    oauth2: true
    # 同步排程
    sync-scheduling: true
    # API Key 認證
    api-key-auth: true

  # ----- 搜尋配置 -----
  search:
    hybrid:
      # alpha: 關鍵字搜尋權重（0-1），預設 0.3 表示 30% 關鍵字、70% 語意
      # 使用 RRF（Reciprocal Rank Fusion）演算法融合搜尋結果
      alpha: 0.3
      # 語意搜尋的最低相似度閾值（0-1）
      min-similarity: 0.5

  # ----- 同步排程配置 -----
  sync:
    cron: "0 0 2 * * *"  # 每天凌晨 2 點執行

  # ----- GitHub 內容取得配置 -----
  github:
    fetch:
      # 連線超時（毫秒）
      connect-timeout-ms: 10000
      # 讀取超時（毫秒）
      read-timeout-ms: 30000
      # Archive 策略（優先級 1：下載 tarball，最快、無 Rate Limit）
      archive:
        enabled: true
        priority: 1
      # Git Tree API 策略（優先級 2：1 次 API 呼叫取得目錄結構）
      git-tree:
        enabled: true
        priority: 2
      # Contents API 策略（優先級 3：遞迴呼叫，作為最終 fallback）
      contents-api:
        enabled: true
        priority: 3
        rate-limit:
          delay-ms: 100              # 每次請求間隔（毫秒）
          max-requests-per-sync: 500  # 單次同步最大請求數
          retry-count: 3             # 失敗重試次數
          retry-delay-ms: 1000       # 重試間隔（毫秒）
          rate-limit-wait-ms: 60000  # 遇到 Rate Limit 時等待（毫秒）

# ----- 日誌配置 -----
logging:
  level:
    root: INFO
    io.github.samzhu.documentation.platform: INFO
